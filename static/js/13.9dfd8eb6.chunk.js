(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{893:function(n,e){n.exports="# Event loop\n- Event-driven\n- Single-threaded\n- Non-blocking\n---\n\n## Concurrency vs Parallelism\n![Event loop](/images/concurrent_vs_parallel.png)\n---\n\n## Event loop\n\nAll JavaScript code is executed on the event loop which exists outside JavaScript.\n  \nThe structure of the event loop is different between the browsers and node.js\n\n---\n\n## Task Queues\n![Node event loop](/images/event-loop-queues.png)\n\n---\n## Timers\n\n`setTimeout` allow us to execute an action\nafter (at least) the set period of time.\n\n```javascript\n  const timeout = setTimeout(function action() {}, milliseconds);\n  // returns a timeout id that can be used to cancel the timer\n  clearTimeout(timeout);\n```\n---\n\n## Timers\n\n`setInterval` allows us to schedule an action to be executed\nperiodically after at a given interval\n\n```javascript\n  const interval = setInterval(function () {}, milliseconds);\n  // returns an interval id that can be used to cancel the timer\n  clearInterval(interval);\n```\n---\n\n## Microtasks\n\nPromises are resolved at the end of the current event loop task.\nThe following code illustrates the order of execution.\n```javascript\n  // add the given action at the end of the event queue\n  setTimeout(() => console.log('third'), 0);\n\n  // resolve q promise and attach a handler\n  Promise.resolve('second').then(console.log);\n\n  // execute some synchronous code\n  console.log('first');\n\n  // first, second, third\n```\n---\n\n## Browser animation\n\n- The browser calls your function when it's ready to redraw the screen.\n- Optimized for both performance and power usage.\n\n```javascript\n  window.requestAnimationFrame(\n    function draw() {\n      // ideally called around 60 times a second\n    }\n  );\n```\n---\n\n## Browser Event Loop\n\n![Browser event loop](/images/browser-event-loop.png)\n---\n\n## Node.js Event Loop\n\n![Node event loop](/images/node-event-loop-phases.png)\n---\n\n## Blocking the event loop\n\nIf the current task falls into an infinite loop\nlater tasks on the event queue will not be processed  \n\n```javascript\n  const longSyncTask = () => {\n    while (true) {}\n  };\n\n  longSyncTask();\n```\n---\n\n## Blowing the stack\n\nChaining too many function calls can lead\nto exceeding the size of the call stack.\nThe following code will eventually throw an error.\n\n```javascript\n  let b;\n  const a = { exec() { b.exec(); } };\n  b = { exec() { a.exec(); } };\n\n  a.exec();\n  // a calls b calls a calls b\n  // calls a calls b etc..\n```\n---\n\n## Chunking work on the event loop\n\nSplit a long / heavy computation into\nmultiple tasks on the event queue.\nThus allowing the engine to process\nother events in between.\n\n```javascript\n  const longAsyncTask = () => {\n    const workChuncks = [];\n    while (workChunks.length > 0) {\n      // get the last chunk\n      const nextTask = workChunks.pop();\n\n      // reverse using timeouts\n      setTimeout(nextTask, workChunks.length * deleyInMs);\n    }\n  }\n```\n"}}]);
//# sourceMappingURL=13.9dfd8eb6.chunk.js.map