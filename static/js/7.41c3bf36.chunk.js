(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{891:function(n,e){n.exports="# Promises\nrepresent the eventual completion or failure of an asynchronous operation and its resulting value.\n---\n\n## Using promises\n\nPromise objects expose the `then` and `catch` methods\n\n```javascript\n  // Handle a value once it's available\n  waitForAnswer().then(doSomethingWithIt);\n\n  // Or handle just the error if something goes wrong\n  waitForAnswer().catch(handleError);\n\n  // Or handle both with a second argument to `then`\n  waitForAnswer().then(handleAnswer, handleError);\n```\n---\n\n### Catching errors\n\n`handleError` will catch an exceptions coming\nfrom either `waitForAnswer` or `useAnswer`\n```javascript\n  waitForAnswer()\n    .then(useAnswer)\n    .catch(handleError);\n```\n---\n\n### Chaining\n\nEach call of the `then` method returns a new promise\n```javascript\n  getUserProfile()\n    .then(profile => download(profile.image))\n    .then(profileImage => applyEffects(profileImage))\n    .then(imageWithEffects => saveFile(imageWithEffects))\n    .then(() => console.log('done'))\n    .catch(error => console.error('something went wrong'));\n```\n---\n\n### Recovering from errors\n\nCalls to `catch` also return a new promise. Execution continues through the chain.\n\n```javascript\n  waitForAnswer()\n    .catch(logErrorAndDefault)\n    .then(useAnswerOrDefault);\n\n  // useAnswerOrDefault will be called in all cases, even if waitForAnswer threw an error\n```\n---\n\n## Creating promises\n\n```javascript\n  const waitOneMinute = new Promise((resolve, reject) => {\n    setTimeout(resolve, 60 * 1000);\n  });\n\n  waitOneMinute.then(doStuff);\n```\n---\n\n## Promise methods\n\n```javascript\n  Promose.resolve(21)\n    .then(number => number * 2)\n    .then(number => console.log(number));\n\n  Promise.reject('Error')\n    .catch(error => {\n      console.log(error);\n    });\n```\n---\n\n### Fan-out\n\nAdding multiple handlers for the same promise\n```javascript\n  const p1 = Promise.resolve(10);\n  \n  const p2 = p1.then(answer => answer * 2);\n  const p3 = p1.then(answer => answer / 2);\n\n  p2.then(console.log); // 20\n  p3.then(console.log); // 5\n```\n---\n\n### Execution order\nResolved promises are executed each time the current event loop task is completed\n\n```javascript\n  setTimeout(() => console.log('A'), 0);\n  console.log('B');\n  Promise.resolve('C').then(c => console.log(c));\n  console.log('D');\n\n  // B D C A\n```\n---\n\n## Promise methods\n\n```javascript\n   Promise.all([\n     fetch('myScript.js'),\n     fetch('myStyles.css')\n     fetch('myData.json'),\n   ]).then(([script, styles, data]) => {\n     // all 3 resources are available here\n   });\n\n   Promise.race([\n     fetch('source1/data.json'),\n     fetch('source2/data.json')\n   ]).then(data => {\n     // gets the data from the first source to succeed\n   });\n```\n---\n\n### Promise.try proposal\n\n```javascript\n  Promise.try(() => getAnswerMightThrow())\n  .then(useAnswer)\n  .catch(handleError);\n```\n---\n\n### Using fetch\n\nFetch is a function that sends a request to a server and returns a promise\nthat will resolve with the server's response\n\n```javascript\n  fetch('https://path-to.some/data')\n    .then(response => response.json()) // parse the response as json\n    .then(useTheData);\n```\n"}}]);
//# sourceMappingURL=7.41c3bf36.chunk.js.map